Как из мухи сделать слона
-------------------------

Описание ТЗ в файле "Тестовое задание С++.rtf".



Спецификация:
-------------


I. Входные данные

Через командную строку передаются два аргумента:

1. Путь к текстовому файлу, в котором указано начальное и конечное слово. На первой строке указано начальное слово, на второй строке конечное. Кодировка файла UTF-8.

2. Путь к файлу, который содержит словарь. Слова в словаре указаны по одному на каждой строке. В словаре слова могут быть разной длины. Кодировка файла UTF-8.



II. Выходные данные

На выходе программа должна вывести в консоль путь от исходного слова к конечному, по одному слову на одной строке.



III. Формат входных файлов

1. Формат файла, содержащего начальное и конечное слова. 
1-ая строка -- начальное слово.
2-ая строка -- конечное слово.
Пустая 1-ая или 2-ая строки -- ошибка. 
Слова состоят только из букв: цифры, пробелы, знаки пунктуации, другие символы -- ошибка. Алфавит не важен, допустимо использование любых символов любого алфавита.


2. Формат файла, содержащего словарь
Каждая строка -- отдельное слово словаря.
Пустая строка не является ошибкой (можно использовать для логического отделения групп слов в словаре).
Слова состоят только из букв: цифры, пробелы, знаки пунктуации, другие символы -- ошибка. Алфавит не важен, допустимо использование любых символов любого алфавита. Словарь должен содержать начальное и конечное слова.


3. Кодировка входных файлов
Кодировка входных файлов -- UTF-8 без сигнатуры. UTF-8 является стандартной кодировкой Linux-систем и позволяет легко сделать программу универсальной по отношению к языку.
При чтении в Linux UTF-8 файлов, созданных в Windows (для которых перевод строки обозначен двумя символами CR+LF), последним символом считанной строки становится символ CR. Наличие этого символа в конце строки проверяется для каждого введенного слова и, в случае его наличия, символ отбрасывается.



IV. Реакция на ошибку во входных данных

При обнаружении ошибки во входных файлах, в консоль выводится сообщение с указанием места и типа ошибки, выполнение программы останавливается. 



V. Основные используемые алгоритмы

1. Поиск пути от начального слова к конечному осуществляется по алгоритму Дейкстры, модифицированным для ребер с одинаковым весом.

Словарь представляется в виде графа, где вершинами являются слова, а ребрами -- связи между словами (когда слова отличаются только одной буквой). Каждой вершине сопостовляется метка, означающая минимальное известное количество ребер в пути до данной вершине от начальной (метка начальной вершины равна 0). Изначально метки всех вершин, кроме начальной приняты равными бесконечности. 

Перебор вершин построен по принципу очереди с приоритетом (каждую итерацию из очереди извлекается вершина с наименьшей меткой). Первой в очередь помещается начальная вершина. 
Далее, пока очередь не опустеет, извлекается очередная вершина (обозначим ее u) и рассматриваются ее соседние вершины. 
Если у соседней вершины метка не равна бесконечности, это означает, что вершина уже рассматривалась, путь до нее уже рассчитан и вершина помещена в очередь. Так как у ребер графа нет весов (у всех ребер вес одинаков и равен 1), длина пути равна количеству переходов между вершинами и используя очередь с приоритетом при первом рассмотрении вершины для нее автоматически вычисляется минимальный путь (значение метки).
Если у соседней вершины метка равна бесконечности (вершина еще не рассматривалась) для нее выполняются следующие действия:
а) метке соседней вершины присваивается значение метки для вершины u + 1;
б) сохраняется информация о том, из какой вершины был осуществлен переход (т.е. сохраняется номер вершины u);
в) вершина помещается в очередь;
г) если соседняя вершина является конечной, значит кратчайший путь найден и алгоритм завершается без просмотра всех вершин.
Если очередь пуста, а конечная вершина не была рассмотрена (ее метка равна бесконечности), значит в данном графе нет пути от начальной вершины до конечной.

Объекты программной реализации алгоритма Дейкстры:

а) DistanceInfinite - наибольшее значение целого числа принимается как признак бесконечности.

б) WordLinks - список связей, хранит указатели на элементы ассоциативного массива WordsDict, представляющего словарь. Хранение указателей, вместо слов словаря, позволяет экономить память и увеличить скорость поиска.

в) WordsDict - словарь. Является ассоциативным массивом, где ключом является слово.

г) WordsDictionaryArray - ассоциативный массив словарей, где ключом является число, равное количеству букв в словах данного словаря. Данное разбиение общего словаря на отдельные немного ускоряет формирование таблиц связей и поиск пути.

д) FindData - служебная структура для алгоритма Дейкстры. Служит для хранения метки, ссылки на вершину, из которой осуществлен переход, указатель на элемент словаря. Именно указатель на данную структура помещается в очередь. 

е) MapFindData - ассоциативный массив хранения служебных структур FindData. Заполняется последовательно по мере рассмотрения вершин.

ж) priority_queue<FindData*, vector<FindData*>, CompareWordData> queWords - очередь хранения указателей на служебную структуру FindData.

з) CompareWordData - класс для сравнения структур FindData. Используется priority_queu<...> при размещении элементов.

и) CFindPath - основной класс словаря. Реализует добавление слов в словарь и поиск кратчайшего пути.

Примечание 1: использование указателей на элементы контейнеров map допустимо, т.к. при добавлении в map элементов итераторы остаются корректными.

Примечание 2: корректировка списка связей соседних слов словаря (ребра графа) осуществляется в момент добавления каждого слова. При этом замедляется процедура добавления, но ускоряется вычисление пути.


2. Организация вывода ошибок

Ошибочные состояния программы (отсутствие файла, некорректные слова и пр.) вызывают исключение Exception с соответствующим ошибке тексом. Исключение перехватывается основным модулем программы и текст выводится в консоль.



VI. Составные модули

1. main.cpp - основной модуль, точка входа программы. Осуществляет вызов подпрограмм загрузки файлов и расчета пути. Перехватывает исключения для ошибок и выводит текст ошибки.
Также в данном модуле макросом _UTEST включается режим модульного тестирования.

2. LoadFile.h/cpp - модуль загрузки слов из файлов.
Содержит функции загрузки файл начального/конечного слов и файла словаря:
а) LoadBeginEndWords - загрузка начального и конечного слов;
б) LoadDicWords - загрузка словаря.

3. FindPath.h/cpp, Dictionary.h - модуль поиска кратчайшего маршрута от начального слова до конечного слова. Содержит класс словаря CFindPath.
Функции класса CFindPath:
а) AddWord - добавленик слов в словарь; также сразу осуществляется поиск соседних слов и сохранение таблицы связей между словами;
б) Clear - очистка словаря (в данной программе не применяется);
в) Find - поиск кратчайшего маршрута.
Файл Dictionary.h содержит интерфейс добавления слова (базовый абстрактный класс IDictionary с чисто виртуальной функцией AddWord) для использования в модуле загрузки файлов (интерфейс IDictionary используется в функции загрузки словаря LoadDicWords).

4. Verify.h/cpp - модуль для проверки корректности слов.
Содержит функцию проверки корректности слова VerifyWord.

5. utf8.h/cpp - модуль поддержки UTF-8. 
Содержит функции преобразования слов из UTF-8 в строку из широких символов std::wstring и обратно (UTF8toW и WtoUTF8, соответственно).
Модуль также содержит оператор << для вывода строки std::wstring в поток вывода с автоматическим преобразованием в UTF-8.

6. messages.h/cpp - служебный модуль с текстовыми сообщениями программы, описанием исключения Exception и функцией форматирования строки (MakeMessage).

7. _test_FindPath.h/_test_LoadFile.h/_test_Types.h - технологические файлы, содержащие процедуры модульного тестирования (реализация технологии разработки TDD). Включаются определением макроса _UTEST в модуле main.cpp.



VII. Шаблон проектирования

1. Проектирование программы основывалось на шаблоне функционального дизайна. При разработке модулей основное внимание уделялось миниммзации влияния работы модуля на остальные части программы. 

2. Для взаимодействия подпрограммы загрузки словаря LoadDicWords с объектом словаря (класс CFindPath модуля FindPath) ипользован шаблон проектирования "Интерфейс" (класс IDictionary файла Dictionary.h).



VIII. Получение исполняемого файла

Для автоматизации получения исполняемого файла сформирован файл Makefile (в усеченном варианте - только сборка и очистка).

Используйте:
make		- для компиляции модулей и сборки исполняемого файла;
make clean	- для очистки проекта от объектных файлов;
./fly_elephant  - вывод подсказки;
./fly_elephant имя_файла1 имя_файла2   - выполнение.



